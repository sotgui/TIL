### 백트래킹 BackTracking

* 브루트포스 : 모든 경우의 수
* 백트래킹 : 노드의 유망성을 판단하여 탐색 생략
  * DFS(깊이우선탐색)
  * BFS(너비우선탐색)



#### DFS (깊이우선탐색)

* boolean[] checked(or visited) 배열 필요 
  * 필수는 아님! (ex. N-Queen)

* int[] arr : 탐색 중 값을 담을 배열
* 재귀함수로 탐색 구현
  * depth 변수 필요 : 재귀함수 들어갈 때마다 depth +1, 목표 깊이 도달 시 return
  * 예시 // boj15649

```java
import java.util.*;
public class Main
{
    static int n;
    static int m;
    static boolean[] checked;
    static int[] arr;
	public static void main(String[] args) {
	    Scanner sc = new Scanner(System.in);
	    n = sc.nextInt();
	    m = sc.nextInt();
	    checked = new boolean[n];
	    arr = new int[m];
	    dfs(0);
	}
	static void dfs(int depth){
	    if(depth == m){         // 깊이가 m과 같아지면 출력하고 return
	        for(int val : arr){
	            System.out.print(val + " ");
	        }
	        System.out.println();
	        return;
	    }
	    for(int i = 0; i<n; i++){
	        if(checked[i] == false){
	            checked[i] = true;      // i를 방문했음
	            arr[depth] = i + 1;     // 배열의 depth번째 수 = i+1
	            dfs(depth+1);           // 다음 depth 탐색
	            checked[i] = false;     // 자식노드를 방문하고 나왔으면 다시 방문가능 상태로 설정해줘야 함!!
	        }
	    }
	}
}
```



#### N-Queen

* `boolean[] isDanger` (배열) 보다 `static boolean isDanger(int d)` (함수)가 더 효율적!
  * 퀸을 넣었다 뺐다 하기 때문.. 하위 노드 방문 후 visited 상태를 다시 false로 돌리는 게 굉장히 엄청난 낭비이다.
  * 심지어 사실 `boolean[][]` 2차원 배열로 나타내야함 개에바

